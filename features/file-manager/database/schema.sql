-- =====================================================
-- BioDocs AI - File Manager Database Schema
-- Wasabi S3 Storage Integration
-- =====================================================
-- Run this SQL in Supabase Dashboard > SQL Editor
-- This creates all tables needed for the file manager
-- =====================================================

-- =====================================================
-- 1. FILE COLLECTIONS TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS file_collections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    color TEXT DEFAULT '#3b82f6',
    icon TEXT DEFAULT 'folder',
    is_smart BOOLEAN DEFAULT false,
    smart_filter JSONB,
    file_count INTEGER DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT "file_collections_user_id_fkey" FOREIGN KEY (user_id) REFERENCES "User"(id) ON DELETE CASCADE
);

-- Indexes for collections
CREATE INDEX IF NOT EXISTS idx_file_collections_user ON file_collections(user_id);
CREATE INDEX IF NOT EXISTS idx_file_collections_name ON file_collections(user_id, name);

-- =====================================================
-- 2. USER FILES TABLE (Main file metadata)
-- =====================================================
CREATE TABLE IF NOT EXISTS user_files (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id TEXT NOT NULL,
    collection_id UUID,
    
    -- File info
    filename TEXT NOT NULL,
    original_name TEXT NOT NULL,
    file_url TEXT NOT NULL,                          -- URL from storage provider (Wasabi/UploadThing)
    file_key TEXT,                                   -- Storage key/path (e.g., users/{userId}/files/...)
    storage_provider TEXT DEFAULT 'wasabi',          -- wasabi, uploadthing, supabase
    file_type TEXT NOT NULL,                         -- pdf, doc, docx, image, etc.
    mime_type TEXT,
    file_size INTEGER NOT NULL,
    
    -- Processing status
    status TEXT DEFAULT 'ready' CHECK (status IN ('uploading', 'processing', 'indexed', 'ready', 'error')),
    processing_error TEXT,
    is_indexed BOOLEAN DEFAULT false,
    
    -- Content extraction
    extracted_text TEXT,
    page_count INTEGER,
    word_count INTEGER,
    
    -- AI-generated metadata
    ai_summary TEXT,
    ai_category TEXT,                                -- Medical, Research, Legal, etc.
    
    -- User metadata
    is_favorite BOOLEAN DEFAULT false,
    is_generated BOOLEAN DEFAULT false,              -- True if generated by AI (not uploaded)
    source_feature TEXT,                             -- Which feature generated it: deep-research, presentation, etc.
    
    -- Timestamps
    last_accessed_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT "user_files_user_id_fkey" FOREIGN KEY (user_id) REFERENCES "User"(id) ON DELETE CASCADE,
    CONSTRAINT "user_files_collection_id_fkey" FOREIGN KEY (collection_id) REFERENCES file_collections(id) ON DELETE SET NULL
);

-- Indexes for files
CREATE INDEX IF NOT EXISTS idx_user_files_user ON user_files(user_id);
CREATE INDEX IF NOT EXISTS idx_user_files_collection ON user_files(collection_id);
CREATE INDEX IF NOT EXISTS idx_user_files_type ON user_files(file_type);
CREATE INDEX IF NOT EXISTS idx_user_files_favorite ON user_files(user_id, is_favorite);
CREATE INDEX IF NOT EXISTS idx_user_files_created ON user_files(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_user_files_storage_provider ON user_files(storage_provider);
CREATE INDEX IF NOT EXISTS idx_user_files_file_key ON user_files(file_key);

-- =====================================================
-- 3. FILE TAGS TABLE (AI + Manual tags)
-- =====================================================
CREATE TABLE IF NOT EXISTS file_tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID NOT NULL,
    user_id TEXT NOT NULL,
    tag_name TEXT NOT NULL,
    tag_type TEXT DEFAULT 'manual',                  -- manual, ai-generated, system
    confidence FLOAT,                                -- AI confidence score (0-1)
    color TEXT DEFAULT '#6b7280',
    is_ai_generated BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT "file_tags_file_id_fkey" FOREIGN KEY (file_id) REFERENCES user_files(id) ON DELETE CASCADE,
    CONSTRAINT "file_tags_user_id_fkey" FOREIGN KEY (user_id) REFERENCES "User"(id) ON DELETE CASCADE,
    UNIQUE(file_id, tag_name)
);

-- Indexes for tags
CREATE INDEX IF NOT EXISTS idx_file_tags_file ON file_tags(file_id);
CREATE INDEX IF NOT EXISTS idx_file_tags_user ON file_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_file_tags_name ON file_tags(tag_name);

-- =====================================================
-- 4. FILE CHUNKS TABLE (For RAG/Embeddings)
-- =====================================================
CREATE TABLE IF NOT EXISTS file_chunks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID NOT NULL,
    chunk_index INTEGER NOT NULL,
    content TEXT NOT NULL,
    embedding vector(1536),                          -- OpenAI embeddings dimension
    start_position INTEGER,
    end_position INTEGER,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT "file_chunks_file_id_fkey" FOREIGN KEY (file_id) REFERENCES user_files(id) ON DELETE CASCADE
);

-- Indexes for chunks
CREATE INDEX IF NOT EXISTS idx_file_chunks_file ON file_chunks(file_id);
CREATE INDEX IF NOT EXISTS idx_file_chunks_embedding ON file_chunks USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);

-- =====================================================
-- 5. COLLECTION SHARES TABLE
-- =====================================================
CREATE TABLE IF NOT EXISTS collection_shares (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    collection_id UUID NOT NULL,
    shared_with_user_id TEXT,                        -- NULL if shared via email (pending)
    shared_with_email TEXT NOT NULL,
    role TEXT DEFAULT 'viewer' CHECK (role IN ('viewer', 'editor')),
    status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected')),
    invited_by TEXT NOT NULL,
    invited_at TIMESTAMPTZ DEFAULT NOW(),
    accepted_at TIMESTAMPTZ,
    
    CONSTRAINT "collection_shares_collection_id_fkey" FOREIGN KEY (collection_id) REFERENCES file_collections(id) ON DELETE CASCADE,
    CONSTRAINT "collection_shares_shared_with_user_id_fkey" FOREIGN KEY (shared_with_user_id) REFERENCES "User"(id) ON DELETE CASCADE,
    CONSTRAINT "collection_shares_invited_by_fkey" FOREIGN KEY (invited_by) REFERENCES "User"(id) ON DELETE CASCADE,
    UNIQUE(collection_id, shared_with_email)
);

-- Indexes for shares
CREATE INDEX IF NOT EXISTS idx_collection_shares_collection ON collection_shares(collection_id);
CREATE INDEX IF NOT EXISTS idx_collection_shares_user ON collection_shares(shared_with_user_id);
CREATE INDEX IF NOT EXISTS idx_collection_shares_email ON collection_shares(shared_with_email);

-- =====================================================
-- 6. SHARED COLLECTION LINKS TABLE (Public links)
-- =====================================================
CREATE TABLE IF NOT EXISTS shared_collection_links (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    collection_id UUID NOT NULL UNIQUE,
    share_link TEXT NOT NULL UNIQUE,
    is_active BOOLEAN DEFAULT true,
    access_type TEXT DEFAULT 'public' CHECK (access_type IN ('public', 'login')),
    role TEXT DEFAULT 'viewer' CHECK (role IN ('viewer', 'editor')),
    created_by TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,
    
    CONSTRAINT "shared_collection_links_collection_id_fkey" FOREIGN KEY (collection_id) REFERENCES file_collections(id) ON DELETE CASCADE,
    CONSTRAINT "shared_collection_links_created_by_fkey" FOREIGN KEY (created_by) REFERENCES "User"(id) ON DELETE CASCADE
);

-- Indexes for links
CREATE INDEX IF NOT EXISTS idx_shared_collection_links_link ON shared_collection_links(share_link);
CREATE INDEX IF NOT EXISTS idx_shared_collection_links_collection ON shared_collection_links(collection_id);

-- =====================================================
-- 7. ROW LEVEL SECURITY POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE file_collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_files ENABLE ROW LEVEL SECURITY;
ALTER TABLE file_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE file_chunks ENABLE ROW LEVEL SECURITY;
ALTER TABLE collection_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE shared_collection_links ENABLE ROW LEVEL SECURITY;

-- File Collections Policies
DROP POLICY IF EXISTS "Users can view own collections" ON file_collections;
CREATE POLICY "Users can view own collections" ON file_collections
    FOR SELECT USING (auth.uid()::text = user_id);

DROP POLICY IF EXISTS "Users can insert own collections" ON file_collections;
CREATE POLICY "Users can insert own collections" ON file_collections
    FOR INSERT WITH CHECK (auth.uid()::text = user_id);

DROP POLICY IF EXISTS "Users can update own collections" ON file_collections;
CREATE POLICY "Users can update own collections" ON file_collections
    FOR UPDATE USING (auth.uid()::text = user_id);

DROP POLICY IF EXISTS "Users can delete own collections" ON file_collections;
CREATE POLICY "Users can delete own collections" ON file_collections
    FOR DELETE USING (auth.uid()::text = user_id);

-- User Files Policies
DROP POLICY IF EXISTS "Users can view own files" ON user_files;
CREATE POLICY "Users can view own files" ON user_files
    FOR SELECT USING (auth.uid()::text = user_id);

DROP POLICY IF EXISTS "Users can insert own files" ON user_files;
CREATE POLICY "Users can insert own files" ON user_files
    FOR INSERT WITH CHECK (auth.uid()::text = user_id);

DROP POLICY IF EXISTS "Users can update own files" ON user_files;
CREATE POLICY "Users can update own files" ON user_files
    FOR UPDATE USING (auth.uid()::text = user_id);

DROP POLICY IF EXISTS "Users can delete own files" ON user_files;
CREATE POLICY "Users can delete own files" ON user_files
    FOR DELETE USING (auth.uid()::text = user_id);

-- File Tags Policies
DROP POLICY IF EXISTS "Users can manage own file tags" ON file_tags;
CREATE POLICY "Users can manage own file tags" ON file_tags
    FOR ALL USING (auth.uid()::text = user_id);

-- File Chunks Policies
DROP POLICY IF EXISTS "Users can view chunks of own files" ON file_chunks;
CREATE POLICY "Users can view chunks of own files" ON file_chunks
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM user_files 
            WHERE user_files.id = file_chunks.file_id 
            AND user_files.user_id = auth.uid()::text
        )
    );

-- Collection Shares Policies
DROP POLICY IF EXISTS "Users can view shares they created or received" ON collection_shares;
CREATE POLICY "Users can view shares they created or received" ON collection_shares
    FOR SELECT USING (
        auth.uid()::text = invited_by 
        OR auth.uid()::text = shared_with_user_id
    );

DROP POLICY IF EXISTS "Users can insert shares for own collections" ON collection_shares;
CREATE POLICY "Users can insert shares for own collections" ON collection_shares
    FOR INSERT WITH CHECK (
        EXISTS (
            SELECT 1 FROM file_collections 
            WHERE file_collections.id = collection_shares.collection_id 
            AND file_collections.user_id = auth.uid()::text
        )
    );

-- Shared Collection Links Policies
DROP POLICY IF EXISTS "Users can manage links for own collections" ON shared_collection_links;
CREATE POLICY "Users can manage links for own collections" ON shared_collection_links
    FOR ALL USING (auth.uid()::text = created_by);

DROP POLICY IF EXISTS "Anyone can view active links" ON shared_collection_links;
CREATE POLICY "Anyone can view active links" ON shared_collection_links
    FOR SELECT USING (is_active = true);

-- =====================================================
-- 8. FUNCTIONS
-- =====================================================

-- Function to update file_count in collections
CREATE OR REPLACE FUNCTION update_collection_file_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE file_collections 
        SET file_count = file_count + 1, updated_at = NOW()
        WHERE id = NEW.collection_id;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE file_collections 
        SET file_count = file_count - 1, updated_at = NOW()
        WHERE id = OLD.collection_id;
    ELSIF TG_OP = 'UPDATE' AND OLD.collection_id IS DISTINCT FROM NEW.collection_id THEN
        -- Decrement old collection
        IF OLD.collection_id IS NOT NULL THEN
            UPDATE file_collections 
            SET file_count = file_count - 1, updated_at = NOW()
            WHERE id = OLD.collection_id;
        END IF;
        -- Increment new collection
        IF NEW.collection_id IS NOT NULL THEN
            UPDATE file_collections 
            SET file_count = file_count + 1, updated_at = NOW()
            WHERE id = NEW.collection_id;
        END IF;
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Create trigger for file count
DROP TRIGGER IF EXISTS trigger_update_collection_file_count ON user_files;
CREATE TRIGGER trigger_update_collection_file_count
    AFTER INSERT OR UPDATE OR DELETE ON user_files
    FOR EACH ROW EXECUTE FUNCTION update_collection_file_count();

-- Function to update timestamps
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers for updated_at
DROP TRIGGER IF EXISTS trigger_user_files_updated_at ON user_files;
CREATE TRIGGER trigger_user_files_updated_at
    BEFORE UPDATE ON user_files
    FOR EACH ROW EXECUTE FUNCTION update_updated_at();

DROP TRIGGER IF EXISTS trigger_file_collections_updated_at ON file_collections;
CREATE TRIGGER trigger_file_collections_updated_at
    BEFORE UPDATE ON file_collections
    FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- =====================================================
-- 9. COMMENTS
-- =====================================================
COMMENT ON TABLE user_files IS 'User uploaded and AI-generated files with metadata, stored in Wasabi S3';
COMMENT ON COLUMN user_files.file_url IS 'Public or signed URL to access the file';
COMMENT ON COLUMN user_files.file_key IS 'Storage key/path in Wasabi (e.g., users/{userId}/files/2024/12/abc123_filename.pdf)';
COMMENT ON COLUMN user_files.storage_provider IS 'Storage service: wasabi (default), uploadthing (legacy), or supabase';
COMMENT ON TABLE file_collections IS 'User-created folders/collections for organizing files';
COMMENT ON TABLE file_tags IS 'Tags attached to files - can be manual or AI-generated';
COMMENT ON TABLE file_chunks IS 'Text chunks from files with embeddings for semantic search';
COMMENT ON TABLE collection_shares IS 'Sharing permissions for collections with other users';
COMMENT ON TABLE shared_collection_links IS 'Public share links for collections';

-- =====================================================
-- DONE! File Manager schema is ready.
-- =====================================================
